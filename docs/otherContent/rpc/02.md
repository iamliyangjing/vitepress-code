## 注册中心

​	注册中心首先是要有的。比较推荐使用 Zookeeper 作为注册中心。当然了，你也可以使用Nacos，甚至是Redis。

​	ZooKeeper为我们提供了高可用、高性能、稳定的分布式数据一致性解决方案，通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。并且，ZooKeeper将数据保存在内存中，性能是非常棒的。在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。(“读”多于“写”是协调服务的典型场景)。动物园管理员为我们提供了高可用、高性能、稳定的分布式数据一致性解决方案，通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能.并且，动物园管理员将数据保存在内存中，性能是非常棒的.在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。(“读”多于“写”是协调服务的典型场景“)

​	**注册中心负责服务地址的注册与查找，相当于目录服务。**服务端启动的时候将服务名称及其对应的地址（ip + port）注册到注册中心，服务消费根据服务名称找到对应的服务地址。有了服务地址之后，服务消费端就可以通过网络请求服务端了。

​	Dubbo 架构图

![image-20230108230843067](markdown-img/02.assets/image-20230108230843067.png)

上述节点简单说明：

- **Provider**:暴露服务的服务提供方
- **Consumer：** 调用远程服务的服务消费方
- **Registry：** 服务注册与发现的注册中心
- **Monitor：** 统计服务的调用次数和调用时间监控中心
- **Container：** 服务运行容器



调用关系说明：

1. 服务容器负责启动，加载，运行服务提供者
2. 服务提供者在启动时，向注册中心注册自己提供的服务。
3. 服务消费者在启动时，向注册中心订阅自己所需的服务。
4. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
5. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
6. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。



## 网络传输

**既然我们要调用远程的方法，就要发送网络请求来传递目标类和方法的信息以及方法的参数以及方法的参数等数据到服务提供端。**



网络传输具体实现你可以使用Socket( Java 中最原始、最基础的网络通信方式。但是，Socket是阻塞的、性能低且功能单一)。



你也可以使用同步非阻塞的I/O模型 NIO,但是用它来进行网络编程实在太麻烦了。不过没关系，你可以使用基于NIO的网络编程框架，他将是你最好的选择！

**Netty 介绍：**

1. **Netty 是一个基于 NIO 的client-server（客户端服务器）框架，使用它可以快速简单地开发网络应用程序。**
2. 它极大地简化并简化了TCP和UDP套接字服务器等网络编程,并且性能以及安全性等很多方面甚至都要更好。
3. 支持多种协议如FTP，SMTP，HTTP以及各种二进制和基于文本的传统协议。



## 序列化和反序列化

**要在网络传输数据就要涉及到序列化。<font color='red'>为什么需要序列化和反序列化呢？</font>**

因为网络中传输的数据必须是<font color='red'>二进制的</font>。因此，我们的Java对象没办法直接在网络中传输。为了能够让JAVA对象在网络中传输我们需要将其**序列化**为二进制的数据。我们最终需要的还是目标JAVA对象，因此我们还要将二进制的数据“解析”为目标Java对象，也就是对二进制数据再进行一次反序列化。

另外，不仅网络传输的时候需要用到序列化和反序列化，将对象存储到文件、数据库等场景都需要用到序列化和反序列化。

![image-20230109211115610](markdown-img/02.assets/image-20230109211115610.png)

JDK自带的序列化，只需实现 **Serializable** 接口即可，不过这种方式不推荐，因为不支持跨语言调用并且性能比较差。



现在比较常用的的序列化有 **hessian、kryo、protostuff、json。**

在选择序列化时，我们应该综合考虑以下**几个因素**：

1. 安全性
2. 通用性
3. 兼容性
4. 性能
5. 效率
6. 空间开销

![image-20230109212044603](markdown-img/02.assets/image-20230109212044603.png)

## 动态代理

**RPC的主要目的就是让我们调用远程方法像调用本地方法一样简单，我们不需要关心远程方法调用的细节比如网络传输。**



**怎样才能屏蔽远程方法调用的底层细节呢？**

答案就是**动态代理**。简单来说，当你调用远程方法的时候，实际会通过代理对象来传输网络请求，不然的话，怎么可能直接就调用到远程方法。



## 负载均衡

<font color='red'>负载均衡也是需要的。</font>为啥?
举个例子:我们的系统中的某个服务的访问量特别大，我们将这个服务部署在了多台服务器上，当客户端发起请求的时候，多台服务器都可以处理这个请求。那么，如何正确选择处理该请求的服务器就很关键。假如，你就要一台服务器来处理该服务的请求，那该服务部署在多台服务器的意义就不复存在了。**负载均衡就是为了避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题，我们从负载均衡的这四个字就能明显感受到它的意义。**

讲解：[负载均衡算法](https://www.bilibili.com/video/BV1nJ411s739/?spm_id_from=333.337.search-card.all.click&vd_source=096fea7f26fb5eb046dfbb1b696a456f)



## 传输协议

​	还需要设计一个私有的RPC协议，这个协议是客户端（服务消费方）和服务端（服务提供方）交流的基础。

> 注意！！ 我们这里的RPC协议是应用层的协议，因为传输层TCP是字节流无边界的，所以需要再应用层将传输的报文组装。

​	简单来说：<font color='red'>**通过设计协议，我们定义需要传输那些类型的数据，并且还会规定每一种类型的数据应该占多少字节。这样我们在接收到二进制数据之后，就可以正确的解析出我们需要的数据**</font>。这有一点像密文传输的感觉。

​	通常一些标准的RPC协议包含下面这些内容：

- 魔数 ：**通常是4个字节。这个魔数主要是为了筛选来到服务端的数据包**，有了这个魔数之后，服务端首先取出前面四个字节进行对比，能够在第一时间识别出这个数据包并是遵循自定义协议的，也就是无效数据包，为了安全考虑可以直接关闭连接以节省资源。
- 序列号器编号 ：标识序列化的方式，比如是使用Java自带的序列化，还是Json、Kryo等等方式
- 消息ID ： 消息ID，用于RpcResponse
- 协议版本号： 协议的版本号
